// ---------------------------------------------------------------------------------
// W H O L E   H O U S E   A U T O M A T I O N
//
//   Copyright (C) 2023-Present Wesley M. Conner
//
//   LICENSE
//     Licensed under the Apache License, Version 2.0 (aka Apache-2.0, the
//     "License"), see http://www.apache.org/licenses/LICENSE-2.0. You may
//     not use this file except in compliance with the License. Unless
//     required by applicable law or agreed to in writing, software
//     distributed under the License is distributed on an "AS IS" BASIS,
//     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//     implied.
//
//   Design Notes
//   - Multiple DevWL instances arise due to multiple input() statements.
//   - Initialization of 'state' includes making immutable copies of DeviveWrapper
//     instances, gathered from 'settings'.
// ---------------------------------------------------------------------------------
import com.hubitat.app.DeviceWrapper as DevW
import com.hubitat.app.DeviceWrapperList as DevWL
import com.hubitat.app.InstalledAppWrapper as InstAppW
import com.hubitat.hub.domain.Event as Event
import com.hubitat.hub.domain.Location as Loc
//#include wesmc.PBSG
#include wesmc.UtilsLibrary

definition(
  name: 'WholeHouseAutomation',
  namespace: 'wesmc',
  author: 'Wesley M. Conner',
  description: 'Whole House Automation using Modes, RA2 and Room Overrides',
  category: '',           // Not supported as of Q3'23
  iconUrl: '',            // Not supported as of Q3'23
  iconX2Url: '',          // Not supported as of Q3'23
  iconX3Url: '',          // Not supported as of Q3'23
  singleInstance: true
)

// """ ... """.stripIndent()

// -------------------------------
// C L I E N T   I N T E R F A C E
// -------------------------------
preferences {
  page(name: 'whaPage', title: '', install: true, uninstall: true)
  page(name: 'roomScenesPage1', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage2', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage3', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage4', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage5', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage6', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage7', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage8', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage9', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage10', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage11', title: '', install: false, uninstall: false)
  page(name: 'roomScenesPage12', title: '', install: false, uninstall: false)
}

// -----------------------------------
// W H A   P A G E   &   S U P P O R T
// -----------------------------------

void solictfocalRooms () {
  roomPicklist = app.getRooms().collect{it.name}.sort()
  //->paragraph "roomPicklist: >${roomPicklist}<"
  collapsibleInput(
    blockLabel: 'Focal Rooms',
    name: 'focalRooms',
    type: 'enum',
    title: 'Select the Focal Rooms',
    options: roomPicklist
  )
}

void solicitLutronTelnetDevice () {
  collapsibleInput (
    blockLabel: 'Lutron Telnet Device',
    name: 'lutronTelnet',
    title: 'Confirm Lutron Telnet Device<br/>' \
      + comment('used to detect Main Repeater LED state changes'),
    type: 'device.LutronTelnet'
  )
}

void solicitLutronMainRepeaters () {
  collapsibleInput (
    blockLabel: 'Lutron Main Repeaters',
    name: 'lutronRepeaters',
    title: 'Identify Lutron Main Repeater(s)<br/>' \
      + comment('used to invoke in-kind Lutron scenes'),
    type: 'device.LutronKeypad'
  )
}

void solicitLutronMiscellaneousKeypads () {
  collapsibleInput (
    blockLabel: 'Lutron Miscellaneous Keypads',
    name: 'lutronMiscKeypads',
    title: 'Identify Lutron Miscellaneous Devices<br/>' \
      + comment('used to trigger room scenes'),
    type: 'device.LutronKeypad'
  )
}

void solicitSeeTouchKeypads () {
  collapsibleInput (
    blockLabel: 'Lutron SeeTouch Keypads',
    name: 'seeTouchKeypad',
    title: 'Identify Lutron SeeTouch Keypads<br/>' \
      + comment('used to trigger room scenes.'),
    type: 'device.LutronSeeTouchKeypad'
  )
}

void solicitLutronPicos () {
  collapsibleInput (
    blockLabel: 'Lutron Picos',
    name: 'lutronPicos',
    title: 'Identify Lutron Picos<br/>' \
      + comment('used to trigger room scenes'),
    type: 'device.LutronFastPico'
  )
}

void solicitSwitches () {
  collapsibleInput (
    blockLabel: 'Lutron LEDs and Non-Lutron Devices',
    name: 'switches',
    title: 'Identify Lutron LEDs and Non-Lutron switches and dimmers' \
      + comment('<br/>Lutron LEDs are set to reflect the current scene.') \
      + comment('<br/>Non-Lutron device levels are set per room scenes.') \
      + comment('<br/>Non-LED Lutron devices can be skipped.') \
      + comment('<br/>VSWs (virtual switches) can be skipped.'),
    type: 'capability.switch'
 )
}

Map whaPage() {
  return dynamicPage(name: 'whaPage') {
    section {
      app.updateLabel('Whole House Automation')
      paragraph heading('Whole House Automation<br/>') \
        + bullet('Select participating rooms and authorize device access.<br/>') \
        + bullet('Click <b>Done</b> to proceed to defining <b>Room Scene(s)</b>.')
      //} else {
      input (
        name: 'LOG',
        type: 'bool',
        title: 'Enable logging?',
        defaultValue: true,
        submitOnChange: true
      )
      solictfocalRooms()
      solicitLutronTelnetDevice()
      solicitLutronMainRepeaters()
      solicitLutronMiscellaneousKeypads()
      solicitSeeTouchKeypads()
      solicitLutronPicos()
      solicitSwitches()
      if (app.getInstallationState() == 'COMPLETE') {
        //settings.focalRooms.eachWithIndex{ roomName, index ->
          href (
            title: "Den Scenes",
            page: "roomScenesPage1",
            width: 2,
            style: 'internal',
            state: 'incomplete'  // or null,
          )
          href (
            title: "Kitchen Scenes",
            page: "roomScenesPage2",
            width: 2,
            style: 'internal',
            state: 'incomplete'  // or null,
          )
        //}
      }
    }
  }
}

// -----------------------------------------------------
// R O O M S   S C E N E S   P A G E   &   S U P P O R T
// -----------------------------------------------------

void solicitModesAsScenes (String roomName) {
  input(
    name: "${roomName}-modesAsScenes",
    type: 'enum',
    title: '<span style="margin-left: 10px;">' \
           + 'Select "Mode Names" to use as "Scene Names" <em>(optional)</em>' \
           + '</span>',
    submitOnChange: true,
    required: false,
    multiple: true,
    options: getLocation().getModes().collect{ mode -> mode.name }
  )
}

void solicitCustomScenes (String roomName) {
  String settingsKeyPrefix = "${roomName}-customScene"
  LinkedHashMap<String, String> slots = [
    "${settingsKeyPrefix}1": settings["${settingsKeyPrefix}1"],
    "${settingsKeyPrefix}2": settings["${settingsKeyPrefix}2"],
    "${settingsKeyPrefix}3": settings["${settingsKeyPrefix}3"],
    "${settingsKeyPrefix}4": settings["${settingsKeyPrefix}4"],
    "${settingsKeyPrefix}5": settings["${settingsKeyPrefix}5"],
    "${settingsKeyPrefix}6": settings["${settingsKeyPrefix}6"],
    "${settingsKeyPrefix}7": settings["${settingsKeyPrefix}7"],
    "${settingsKeyPrefix}8": settings["${settingsKeyPrefix}8"],
    "${settingsKeyPrefix}9": settings["${settingsKeyPrefix}9"]
  ]
  LinkedHashMap<String, String> filled = slots.findAll{it.value}
  // Only present 1 empty sceen "slot" at a time.
  LinkedHashMap<String, String> firstOpen = slots.findAll{!it.value}?.take(1)
  LinkedHashMap<String, String> custom = \
    firstOpen + filled.sort{ a, b -> a.value <=> b.value }
  paragraph 'Add Custom Scene Names <em>(optional)</em>'
  custom.each{ key, value ->
    input(
      name: key,
      type: 'text',
      title: "Custom Scene Name:",
      width: 2,
      submitOnChange: true,
      required: false,
      defaultValue: value
    )
  }
}

List<String> getRoomScenes (String roomName) {
  List<String> scenes = settings["${roomName}-modesAsScenes"]
  String settingsKeyPrefix = "${roomName}-customScene"
  List<String> customScenes = [
    settings["${settingsKeyPrefix}1"],
    settings["${settingsKeyPrefix}2"],
    settings["${settingsKeyPrefix}3"],
    settings["${settingsKeyPrefix}4"],
    settings["${settingsKeyPrefix}5"],
    settings["${settingsKeyPrefix}6"],
    settings["${settingsKeyPrefix}7"],
    settings["${settingsKeyPrefix}8"],
    settings["${settingsKeyPrefix}9"],
  ].findAll{it != null}
  scenes << customScenes
  return scenes.flatten().sort()
}

void solicitSceneForRoomNameModeName (String roomName) {
  List<String> roomScenes = getRoomScenes(roomName)
  paragraph "Select scenes for per-mode automation"
  getLocation().getModes().collect{mode -> mode.name}.each{ modeName ->
    input(
      name: "${roomName}-${modeName}ToScene",
      type: 'enum',
      title: modeName,
      width: 2,
      submitOnChange: true,
      required: true,
      multiple: false,
      options: roomScenes,
      defaultValue: roomScenes.find{sceneName -> sceneName == modeName } ?: ''
    )
  }
}

Map<String, List<String>> getModeToScene (String roomName) {
  return getLocation().getModes()
            .collect{mode -> mode.name}
            .collectEntries{ modeName ->
              [modeName, settings["${roomName}-${modeName}ToScene"]]
            }
}

List<DevW> getMainRepeaters () {
  return settings?.lutronRepeaters
}

void solicitRepeatersForRoomScenes (String roomName) {
  collapsibleInput (
    blockLabel: "Repeaters for ${roomName} Scenes",
    name: "${roomName}-repeaters",
    title: 'Identify Repeater(s) supporting Room Scenes',
    type: 'enum',
    options: getMainRepeaters().collect{ d -> d.displayName }
  )
}

List<DevW> getKeypads() {
  return (settings?.lutronMiscKeypads ?: []) \
         + (settings?.seeTouchKeypad ?: []) \
         + (settings?.lutronPicos ?: [])
}

void solicitKeypadsForRoomScenes (String roomName) {
  collapsibleInput (
    blockLabel: "Keypads for ${roomName} Scenes",
    name: "${roomName}-keypads",
    title: 'Identify Keypad(s) supporting Room Scenes',
    type: 'enum',
    options: getKeypads().collect{ d -> d.displayName }
  )
}

List<DevW> getLedDevices () {
  return settings?.switches.findAll{ it?.displayName.toString().contains('LED') }
}

void solicitLedDevicesForRoomScenes (String roomName) {
  collapsibleInput (
    blockLabel: "LED Devices for ${roomName} Scenes",
    name: "${roomName}-leds",
    title: 'Identify LED Button(s) supporting Room Scenes',
    type: 'enum',
    options: getLedDevices().collect{ d -> d.displayName }
  )
}

List<DevW> narrowDevicestoRoom (String roomName, DevWL devices) {
  // This function excludes devices that are not associated with any room.
  List<String> deviceIdsForRoom = app.getRooms()
                                  .findAll{it.name == roomName}
                                  .collect{it.deviceIds.collect{it.toString()}}
                                  .flatten()
  return devices.findAll{ d ->
    //--paragraph "d: ${d}, d.id: ${d.id}"
    deviceIdsForRoom.contains(d.id.toString())
  }
}

void solicitNonLutronDevicesForRoomScenes (String room) {
  List<DevW> roomSwitches = narrowDevicestoRoom(room, settings?.switches).findAll{
    it.displayName.toString().contains('lutron') == false
  }

  paragraph "roomSwitches: >${roomSwitches}<"
  //roomSwitches.each{ switch ->
  //  paragraph "Switch Id: ${switch.id}, Switch Name: ${switch.displayName}"
  //}

  collapsibleInput (
    blockLabel: "Non-Lutron Devices for ${roomName} Scenes",
    name: "${roomName}-nonLutron",
    title: 'Identify Non-Lutron devices supporting Room Scenes',
    type: 'enum',
    options: roomSwitches.collect{ d -> d.displayName }
  )
}

Closure roomScenesPage = { prefix ->
  dynamicPage(name: "${prefix}Page") {
    section {
      paragraph (
        heading("${prefix} Scenes<br/>")
        + comment(
            'Tab to register changes.<br/>'
            + 'If "Error: Cannot get property" appears, click "â†»" to reload the page.'
          )
      )
      // Mode-named scenes appear as a single settings List<String>.
      // 0..9 custom scenes appear individually as settings prefix1..prefix9.
      solicitModesAsScenes(prefix)
      solicitCustomScenes (prefix)
      solicitSceneForprefixModeName (prefix)
      solicitRepeatersForRoomScenes(prefix)
      solicitKeypadsForRoomScenes(prefix)
      solicitLedDevicesForRoomScenes(prefix)
      solicitNonLutronDevicesForRoomScenes(prefix)

      paragraph "<b>Debug ${prefix} Scenes:</b> ${getRoomScenes(prefix)}"
      paragraph "<b>Debug ${prefix} Mode-to-Scene:</b> ${getModeToScene(prefix)}"
      paragraph "<b>Repeaters:</b> ${settings["${prefix}-repeaters"]}"
      paragraph "<b>Keypads:</b> ${settings["${prefix}-keypads"]}"
      paragraph "<b>LED Devices:</b> ${settings["${prefix}-leds"]}"
      paragraph "<b>Non-Lutron Devices:</b> ${settings["${prefix}-nonLutron"]}"

      //----> Keypad Buttons that Trigger Scenes
      //----> Use a picklist to narrow the required keypads
      //----> List<DevW> keypads = getKeypads()
      //----> paragraph "keypads: ${keypads}"

      /*
      //----> Non-Lutron Devices with per-Scene levels
      List<DevW> nonLutronDevices = parent.getNonLutronDevices(assignedRoom)
      paragraph "nonLutronDevices: ${nonLutronDevices}"

      //----> Main Repeater Buttons that Realize Scenes
      List<DevW> mainRepeaters = parent.getMainRepeaters()
      paragraph "mainRepeaters: ${mainRepeaters}"

      //----> LEDs that are Set on Scene Activaton
      // https://community.hubitat.com/t/bug-report-lutron-ra2-main-repeater-not-reporting-led-status-correctly/63317/7`
      // It appears that your suggestion about subtracting 80 for LED numbers less
      // than 100 and subtracting 100 from those above 100 will work with the
      // outcome of LED number being the same as button number.
      // ----------
      // NOTE: The required keypads likely match the scene-triggering buttons
      List<DevW> leds = parent.getLedDevices()
      paragraph "leds: ${leds}"
      */
    }
  }
}

def roomScenesPage1() { roomScenesPage.call('P1') }
def roomScenesPage2() { roomScenesPage.call('P2') }
def roomScenesPage3() { roomScenesPage.call('P3') }
def roomScenesPage4() { roomScenesPage.call('P4') }
def roomScenesPage5() { roomScenesPage.call('P5') }
def roomScenesPage6() { roomScenesPage.call('P6') }
def roomScenesPage7() { roomScenesPage.call('P7') }
def roomScenesPage8() { roomScenesPage.call('P8') }
def roomScenesPage9() { roomScenesPage.call('P9') }
def roomScenesPage10() { roomScenesPage.call('P10') }
def roomScenesPage11() { roomScenesPage.call('P11') }
def roomScenesPage12() { roomScenesPage.call('P12') }


//LinkedHashMap<String, String>




        /*
        LinkedHashMap unpairedChildAppsByName = getChildAppsByName ()

        //->removeUnpairedChildApps ()
        if (settings.LOG) log.info "childApps: ${childApps.collect{it.getLabel()}.join(', ')}"

        // MapfocalRoomsToRoomSceneApps
        LinkedHashMap roomAppsByName = settings.focalRooms.collectEntries{
          room -> [room, unpairedChildIds.contains(room) ?: null]
        }

        // Prepare to capture the Mode PBSG child app.
        InstAppW pbsgModeApp = null

        // Prepare to remove unused child apps.
        List<String> unusedDeviceNetworkIds = []

        // Parse existing (discovered) Child Apps, removing unaffiliated children.
        List<InstAppW> childApps = getAllChildApps()
        //--
        childApps.each{ childApp ->
          String childLabel = childApp.getLabel()
          if (childLabel == 'pbsg-mode') {
            pbsgModeApp = childApp
          } else if (settings.focalRooms.contains(childLabel)) {
            roomAppsByName.putAt(childLabel, child)
          } else {
            unusedDeviceNetworkIds << childApp.deviceNetworkId
          }
        }
        unusedDeviceNetworkIds.each{ deviceNetworkId ->
          if (settings.LOG) log.info "Removing stale childApps ${deviceNetworkId}"
          deleteChildDevice(deviceNetworkId)
        }

        */


// ------------------------------------------------------------------------
// M E T H O D S   B A S E D   O N   S E T T I N G S
//   Clients can use the following methods (which operate exclusively on
//   Parent'settings' when rendering data entry screens.
// ------------------------------------------------------------------------
/*
String assignChildAppRoomName (Long childAppId) {
  List<String> focalRooms = settings.focalRooms
  List<InstAppW> kidApps = getChildApps()
  Map<String, String> kidIdToRoomName =
    kidApps.collectEntries{ kid ->
      [ kid.id.toString(), focalRooms.contains(kid.label) ? kid.label : null ]
  }
  Map<String, Boolean> roomNameToKidId = focalRooms.collectEntries{[it, false]}
  kidIdToRoomName.each{ kidId, roomName ->
    if (roomName) roomNameToKidId[roomName] = kidId
  }
  return result = kidIdToRoomName[childAppId.toString()]
                  ?: roomNameToKidId.findAll{!it.value}.keySet().first()
}
*/


//--xx-- Main Repeater LEDs will be used in lieu of individual Lutron
//--xx-- devices to detect Manual overrides.
//--xx--
//--xx-- List<DevW> getLutronDevices (String room) {
//--xx--   return narrowDevicestoRoom(room, settings?.switches).findAll{it.displayName.contains('lutron') && ! it.displayName.contains('LED')}
//--xx-- }


// -------------------------------
// S T A T E   M A N A G E M E N T
// -------------------------------

void installed() {
  if (settings.LOG) log.trace 'WHA installed()'
  initialize()
}

void updated() {
  if (settings.LOG) log.trace 'WHA updated()'
  unsubscribe()  // Suspend event processing to rebuild state variables.
  initialize()
}

void testHandler (Event e) {
  // SAMPLE 1
  //   descriptionText  (lutron-80) TV Wall KPAD button 1 was pushed [physical]
  //          deviceId  5686
  //       displayName  (lutron-80) TV Wall KPAD
  if (settings.LOG) log.trace "WHA testHandler() w/ event: ${e}"
  if (settings.LOG) logEventDetails(e, false)
}

void initialize() {
  if (settings.LOG) log.trace "WHA initialize()"
  if (settings.LOG) log.trace "WHA subscribing to Lutron Telnet >${settings.lutronTelnet}<"
  settings.lutronTelnet.each{ d ->
    DevW device = d
    if (settings.LOG) log.trace "WHA subscribing ${device.displayName} ${device.id}"
    subscribe(device, testHandler, ['filterEvents': false])
  }
  if (settings.LOG) log.trace "WHA subscribing to Lutron Repeaters >${settings.lutronRepeaters}<"
  settings.lutronRepeaters.each{ d ->
    DevW device = d
    if (settings.LOG) log.trace "WHA subscribing to ${device.displayName} ${device.id}"
    subscribe(device, testHandler, ['filterEvents': false])
  }
  if (settings.LOG) log.trace "WHA subscribing to lutron SeeTouch Keypads >${settings.seeTouchKeypad}<"
  settings.seeTouchKeypad.each{ d ->
    DevW device = d
    if (settings.LOG) log.trace "WHA subscribing to ${device.displayName} ${device.id}"
    subscribe(device, testHandler, ['filterEvents': false])
  }

  //ArrayList<LinkedHashMap> modes = getModes()
  // Rebuild the PBSG mode instance adjusting (i.e., reusing or dropping)
  // previously-created VSWs to align with current App modes.
  //if (state['pbsg-modes']) { deletePBSG(name: 'pbsg-modes', dropChildVSWs: false) }
  //createPBSG(
  //  name: 'pbsg-modes',
  //  sceneNames: modes.collect{it.name},
  //  defaultScene: 'Day'
  //)
}

// -----------
// U N U S E D
// -----------

//--MISSING->displayParticipatingDevices()
//--MISSING->displayAppInfoLink()

LinkedHashMap<String, InstAppW> getAllChildAppsByLabel () {
  return getAllChildApps().collectEntries{
    childApp -> [ childApp.getLabel(), childApp ]
  }
}

void displayCustomScenes () {
  paragraph(
    '<table>'
      + params.collect{ k, v -> "<tr><th>${k}</th><td>${v}</td></tr>" }.join()
      + '</table>'
  )
}
